<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1 算法设计与分析之导学</title>
    <url>/2020/06/22/1%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E5%AF%BC%E5%AD%A6/</url>
    <content><![CDATA[<p>  本博文简单介绍了算法的相关概念(包括：算法设计模式、算法性质、描述方式、评价方法等)以及时间复杂度分析。</p>
<h2 id="1-导学"><a href="#1-导学" class="headerlink" title="1 导学"></a>1 导学</h2><h3 id="1-1-算法的基本概念"><a href="#1-1-算法的基本概念" class="headerlink" title="1.1 算法的基本概念"></a>1.1 算法的基本概念</h3><p><strong>算法设计模式：</strong></p>
<ul>
<li>暴力求解(Brute force)</li>
<li>分治法(Divide and conquer)</li>
<li>贪婪算法(Greedy approach)</li>
<li>动态规划(Backtracking)</li>
<li>回溯法(Branch and bound)</li>
<li>分支界限法(Randomized algorithm)等</li>
</ul>
<p><strong>算法</strong>：算法是借助计算机解决问题的方法，是有限条确定性指令的序列</p>
<p><strong>算法的性质</strong>：输入、输出、确定性、有限性</p>
<p><strong>算法的描述方式</strong>：自然语言、数学公式、流程图、伪代码、程序设计语言</p>
<p><strong>算法的评价方法：</strong>正确性、有效性、易理解、易实现、通用性</p>
<p><strong>例子：最大公约数</strong><br>暴力解法：取min(a,b)，从大到小尝试，直到两个数均可被整除。<br>欧几里得：<code>max%min==0？result=min : result=(max%min和min的最大公约数）</code></p>
<h3 id="1-2-算法复杂度"><a href="#1-2-算法复杂度" class="headerlink" title="1.2 算法复杂度"></a>1.2 算法复杂度</h3><p><strong>算法复杂度分析的三种情形</strong>：</p>
<ul>
<li>最好情形(Best case)</li>
<li>最差情形(Worst case)</li>
<li>平均情形(Average case)</li>
</ul>
<p>例如：二分查找(Binary search)的时间复杂度，在三种情况依次为Θ(1)、Θ(log<sub>2</sub>n)、Θ(log<sub>2</sub>n)</p>
<h4 id="1-2-1-时间复杂度"><a href="#1-2-1-时间复杂度" class="headerlink" title="1.2.1 时间复杂度"></a>1.2.1 时间复杂度</h4><p><strong>评价标准：</strong></p>
<ul>
<li>运行时间<ul>
<li>优点：最直接反映</li>
<li>缺点：机器依赖、缺乏解释</li>
</ul>
</li>
<li>运算次数<ul>
<li>优点：机器无关、具有解释力</li>
<li>缺点：统计繁琐、规模较大时关键在于增长量级</li>
</ul>
</li>
<li>增长量级</li>
</ul>
<p><strong>近似表示</strong><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.1.jpg?raw=true" alt="@图 1.1 上界|center|500x0"><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.2.jpg?raw=true" alt="@图 1.2 下界|center|500x0"><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.3.jpg?raw=true" alt="@图 1.3 同阶|center|500x0"></p>
<p><strong>例子：Fibonacci</strong><br>递归算法：O(2<sup>n</sup>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">GetByRecursion</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> GetByRecursion(n-<span class="number">1</span>)+GetByRecursion(n-<span class="number">2</span>); <span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代算法：O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">GetByIteration</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">long</span> temp=a+b;</span><br><span class="line">		a=b;</span><br><span class="line">		b=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-算法思维"><a href="#1-3-算法思维" class="headerlink" title="1.3 算法思维"></a>1.3 算法思维</h3><p><strong>算法思维：</strong>现实问题——&gt;形式化描述——&gt;设计算法——&gt;方案实施——&gt;现实问题</p>
<h4 id="1-1-4-例：交通信号灯"><a href="#1-1-4-例：交通信号灯" class="headerlink" title="1.1.4 例：交通信号灯"></a>1.1.4 例：交通信号灯</h4>]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>2 算法设计与分析之分治法解决汉诺塔问题</title>
    <url>/2020/06/22/2%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%A3%E5%86%B3%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="2-递归与分治策略"><a href="#2-递归与分治策略" class="headerlink" title="2 递归与分治策略"></a>2 递归与分治策略</h2><h3 id="2-1-算法介绍"><a href="#2-1-算法介绍" class="headerlink" title="2.1 算法介绍"></a>2.1 算法介绍</h3><p><strong>分治法</strong>(Divide and conquer)：将一个规模较大问题分解为规模较小的子问题，先求解这些子问题，然后将各子问题的解合并得到原问题的解的算法思路。</p>
<p><strong>递归</strong>(Recursion)：直接或间接地调用自身的算法。</p>
<ul>
<li>优点：<ul>
<li>是一种自然的思考方式</li>
<li>思路清晰</li>
<li>易于实现</li>
</ul>
</li>
<li>缺点：<ul>
<li>具体执行步骤难以理解</li>
<li>坏的递归大幅提高算法复杂度</li>
</ul>
</li>
</ul>
<p><strong>分治与递归的联系</strong>：分治法的子问题通常与原问题结构和求解方法相同，可以通过<em>递归</em>的方法求解。</p>
<h3 id="2-2-汉诺塔-Hanoi-tower"><a href="#2-2-汉诺塔-Hanoi-tower" class="headerlink" title="2.2 汉诺塔(Hanoi tower)"></a>2.2 汉诺塔(Hanoi tower)</h3><h4 id="2-2-1-问题描述"><a href="#2-2-1-问题描述" class="headerlink" title="2.2.1 问题描述"></a>2.2.1 问题描述</h4><p>有3根柱子及n个不同大小的圆盘，最初，所有盘子由上到下、从小到大地套在第一根柱子上。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。<br>请问：将所有盘子从第一根柱子移到最后一根柱子，如何移动才能移动次数最少？需要移动多少次？</p>
<h4 id="2-2-2-问题解决"><a href="#2-2-2-问题解决" class="headerlink" title="2.2.2 问题解决"></a>2.2.2 问题解决</h4><p>令三个柱子分别为A、B、C，最初所有的盘子都在A上，从宏观上看，要想把A的盘子全部移动到C，则可以：</p>
<ul>
<li>① 将n-1个盘子从A移到B</li>
<li>② 将最下面的1个盘子从A移到C</li>
<li>③ 将n-1个盘子从B移动到C</li>
</ul>
<p>你可能会问，问题要求(1)中明明限制了一次只能移动一个盘子！<br>这个时候就要用到分治和递归的思想，上述三个步骤中，仅有步骤②是直接执行，其中步骤①和步骤③都要通过递归实现。<br>我们先说步骤①，如何把n-1个盘子从A移到B？这可以看成一个新的子问题，而这个子问题跟原问题是一样的，所以我们可以利用递归，再次重复上述的三个步骤就行了，但是，要如何设置参数呢？首先，这个子问题中只有n-1个盘子，所以我们只需要把n改为n-1，其次，要想把n-1个盘子从A移到B，就得先把n-2个盘子从A移到C，依次类推往下…..<br>请你注意：在不断递归的过程中，A、B、C的“移动角色”在不断改变，原问题是把n个盘子从A移到C，子问题为把n-1个盘子从A移到B，子子问题是把n-2个盘子从A移到C…<br>步骤③的原理同步骤②。</p>
<p>建议这段讲解，配合代码一起阅读，将有助于理解。</p>
<h4 id="2-2-3-时间复杂度"><a href="#2-2-3-时间复杂度" class="headerlink" title="2.2.3 时间复杂度"></a>2.2.3 时间复杂度</h4><p>时间复杂度：O(2<sup>n</sup>)<br>分析：<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.4.jpg?raw=true" alt="@图2.1 以五个圆盘为例的时间复杂度分析示意图"><br>我们首先以5个圆盘为例，来分析时间复杂度。<br>这张图的含义：灰色部分为直接执行的步骤②，黄色部分为递归执行的步骤①和③。圆圈内的数字代表圆盘的个数，圆圈旁的数字代表所需执行的步骤数，左侧的式子代表对应一层的执行步骤数。<br>这张图的分析：我们从左侧的式子中可以看出，n=5时，就把每一层的执行步骤数加起来，就是总的执行步骤数，为3+7x2<sup>0</sup>+7x2<sup>1</sup>+7x2<sup>2</sup>+6x2<sup>2</sup><br>推广至n时，则为3+(2<sup>0</sup>+2<sup>1</sup>+…+2<sup>n-3</sup>)+6x2<sup>2</sup>=2.5x2<sup>n</sup>-4,故O(2<sup>n</sup>)</p>
<h4 id="2-2-3-代码实现"><a href="#2-2-3-代码实现" class="headerlink" title="2.2.3 代码实现"></a>2.2.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HanoiSimple</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(Tower A,Tower B,Tower C)</span></span>&#123;</span><br><span class="line">		move(A.size(),A,B,C);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,Tower A,Tower B,Tower C)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;<span class="comment">//终止，只剩一个盘子</span></span><br><span class="line">			C.add(A.remove());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">		    <span class="comment">/*关键代码：实现递归与分治*/</span></span><br><span class="line">			move(n-<span class="number">1</span>,A,C,B);<span class="comment">//将n-1个盘子从A移到B(继续递归)</span></span><br><span class="line">			move(<span class="number">1</span>,A,B,C);<span class="comment">//将最下面的那个盘子从A移到C(真正执行)</span></span><br><span class="line">			move(n-<span class="number">1</span>,B,A,C);<span class="comment">//将n-1个盘子从B移动到C(继续递归)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>Hanoi tower</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>4 算法设计与分析之选择排序</title>
    <url>/2020/06/23/4%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="2-4-1-算法思路"><a href="#2-4-1-算法思路" class="headerlink" title="2.4.1 算法思路"></a>2.4.1 算法思路</h4><p><em>此方法为暴力求解，在此非重点。</em><br>首先选择第一个元素，初始化minIndex=0，然后从第二个元素开始从左往右遍历，找出右边比sortedData[minIndex]更小的元素，就将其序号赋值给minIndex，遍历完右边的所有元素后，交换第i个元素和第minIndex元素。<br>然后选择第二个元素，从第三个元素开始从左往右遍历，其余步骤同上。</p>
<h4 id="2-4-2-代码实现"><a href="#2-4-2-代码实现" class="headerlink" title="2.4.2 代码实现"></a>2.4.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] originalData)&#123;</span><br><span class="line">	<span class="keyword">int</span> [] sortedData=originalData.clone();<span class="comment">//复制一份原始数据，用来保存排序好的数组</span></span><br><span class="line">	<span class="comment">/*核心代码*/</span></span><br><span class="line">	<span class="comment">//注意：这里i取到sortedData.length-2就能保证排序好</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sortedData.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> minIndex=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;sortedData.length;j++)&#123;<span class="comment">//j必须遍历到最后一位</span></span><br><span class="line">			<span class="keyword">if</span>(sortedData[minIndex]&gt;sortedDate[j])&#123;<span class="comment">//如果大于最小值，则将索引保存到minIndex</span></span><br><span class="line">				minIndex=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(sortedData,i,minIndex);<span class="comment">//将i和minIndex的元素交换</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sortedData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-时间复杂度"><a href="#2-4-3-时间复杂度" class="headerlink" title="2.4.3 时间复杂度"></a>2.4.3 时间复杂度</h4><p>时间复杂度：Θ(n<sup>2</sup>)<br>分析：(n-1)+(n-2)+(n-3)+….1=n(n-1)/2</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Selection sort</tag>
      </tags>
  </entry>
  <entry>
    <title>3 算法设计与分析之分治法解决全排列问题</title>
    <url>/2020/06/22/3%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="2-3-1-问题描述"><a href="#2-3-1-问题描述" class="headerlink" title="2.3.1 问题描述"></a>2.3.1 问题描述</h4><p> 给出n个元素的所有可能的排列方式。<br> 如: [1,2,3]的排列有[1,2,3], [1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]</p>
<h4 id="2-3-2-问题解决"><a href="#2-3-2-问题解决" class="headerlink" title="2.3.2 问题解决"></a>2.3.2 问题解决</h4><p>我们最开始有一个nums数组，我们首先从第一位开始排，第一位的值有三种可能，我们先设置一个变量start_index=0，它表示我们目前排到了第几位，然后分别让nums[start_index]和后面几位的元素交换位置，每交换好一次，就确定了那一位的值，然后开始往下一位继续递归，递归完毕后需要恢复到原来的位置，再让nums[start_index]和下一位交换位置。<br>总结来说就是三个步骤：</p>
<ul>
<li>① 交换元素位置</li>
<li>② 递归</li>
<li>③ 恢复元素位置</li>
</ul>
<p>所以整个全排列的实现，其实是按照图中箭头的顺序实现的，向下的箭头都是<strong>交换元素位置</strong>，向上的箭头则是<strong>恢复元素位置</strong>。<br><strong>你可能会不理解为什么要交换和恢复元素位置？</strong><br>简单来说就是，第一位可能是1、2、3三种可能，1和1交换得出1xx排列，1和2交换得出2xx排列，1和3换得出3xx排列。比如2xx的全部排完就是递归结束了，现在得把1和2的位置恢复回来，这样才能保证待会儿1和3交换。如果不恢复位置，就会变成2和3交换了，那就和我们的本意违背了。<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.5.jpg?raw=true" alt="@图2.2 以3个元素为例分析排列问题的示意图"></p>
<h4 id="2-3-3-代码实现"><a href="#2-3-3-代码实现" class="headerlink" title="2.3.3 代码实现"></a>2.3.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">int</span>[]&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">	List&lt;<span class="keyword">int</span>[]&gt; perms=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//保存全排列</span></span><br><span class="line">	permute_recursion(nums,<span class="number">0</span>,perms);</span><br><span class="line">	<span class="keyword">return</span> perms;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permute_recurison</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start_index,List&lt;<span class="keyword">int</span>[]&gt; list)</span></span>&#123;<span class="comment">//参数含义：nums-待排序数组，start_index-排序起始位置，list-全排列</span></span><br><span class="line">	<span class="keyword">int</span> len=nums.length;</span><br><span class="line">	<span class="keyword">if</span>(start_index==len-<span class="number">1</span>)&#123;<span class="comment">//如果排到最后一位，则停止递归，直接加入list</span></span><br><span class="line">		<span class="keyword">int</span> [] perm=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			perm[i]=nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		list.add(perm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">/*核心代码：不断交换位置、递归、恢复位置*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=start_index;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			swap(nums,start_index,i);<span class="comment">//交换nums[start_index]和nums[i]</span></span><br><span class="line">			permute_recursion(nums,start_index+<span class="number">1</span>,list);<span class="comment">//从start_index+1开始递归寻找全排列</span></span><br><span class="line">			swap(nums,start_index,i);<span class="comment">//还原nums[start_index]和nums[i]</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//swap：交换数组的两个元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums ,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=nums[i];</span><br><span class="line">	nums[i]=nums[j];</span><br><span class="line">	nums[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-时间复杂度"><a href="#2-3-4-时间复杂度" class="headerlink" title="2.3.4 时间复杂度"></a>2.3.4 时间复杂度</h4><p>时间复杂度：<code>Ω(n!)</code><br>分析：<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.6.jpg?raw=true" alt="@图2.3 以3个元素为例分析排列问题的时间复杂度"><br>第一层，for循环要执行三次，每次执行都要调用两次swap()函数和一次递归，所以为3+3x3<br>第二层，for循环要执行两次，也是每次执行都要调用两次swap()函数和一次递归，但因为这里有三个分支（分别为1xx、2xx、3xx），所以为(2+2x2)x3<br>…<br>最后一层，不需要执行for循环，有3!个分支，所以是3!<br>同样的分析方法，我们可以得出n个元素的情况，结果见图片。因为最后一层是n!，所以知道时间复杂度的下限为Ω(n!)</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>recursion</tag>
        <tag>Permute</tag>
      </tags>
  </entry>
  <entry>
    <title>5 算法设计与分析之分治法实现合并排序</title>
    <url>/2020/06/23/5%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="2-5-合并排序-merge-sort"><a href="#2-5-合并排序-merge-sort" class="headerlink" title="2.5 合并排序(merge sort)"></a>2.5 合并排序(merge sort)</h3><h4 id="2-5-1-算法思路"><a href="#2-5-1-算法思路" class="headerlink" title="2.5.1 算法思路"></a>2.5.1 算法思路</h4><p>总体步骤：</p>
<ul>
<li>① 拆分</li>
<li>② 合并，边合并边排序</li>
</ul>
<p><em>详细的解释在2.5.2代码注释中</em><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.7.jpg?raw=true" alt="@图2.4 合并排序示意图"></p>
<h4 id="2-5-2-代码及注释"><a href="#2-5-2-代码及注释" class="headerlink" title="2.5.2 代码及注释"></a>2.5.2 代码及注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] originalData)&#123;</span><br><span class="line">	<span class="keyword">int</span> [] sortedData=originalData.clone;<span class="comment">//拷贝一份原数组，用来存排好序的数组</span></span><br><span class="line">	<span class="keyword">int</span> [] tempData=originalData.clone;<span class="comment">//辅助数组，用来保存排序好的一部分数组，</span></span><br><span class="line">	mergeSort(SortedData,<span class="number">0</span>,sortedData.length-<span class="number">1</span>,tempData);</span><br><span class="line">	<span class="keyword">return</span> SortedData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] sortedData,<span class="keyword">int</span> head,<span class="keyword">int</span> tail,<span class="keyword">int</span>[] tempData)</span></span>&#123;</span><br><span class="line">	<span class="comment">/*较为重要的代码*/</span></span><br><span class="line">	<span class="keyword">if</span>(head==tail)<span class="keyword">return</span>;<span class="comment">//拆分到只剩一个元素时</span></span><br><span class="line">	mergeSort(sortedData,head,head+(tail-head)/<span class="number">2</span>,tempData);<span class="comment">//前半段</span></span><br><span class="line">	mergeSort(sortedData,head+(tail-head)/<span class="number">2</span>+<span class="number">1</span>,tail,tempData);<span class="comment">//后半段</span></span><br><span class="line">	merge(sortedData,head,tail,tempData);<span class="comment">//合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] sortedData,<span class="keyword">int</span> head,<span class="keyword">int</span> tail,<span class="keyword">int</span>[] tempData)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> firstPartIndex=head;<span class="comment">//指向前半段的第一个元素</span></span><br><span class="line">	<span class="keyword">int</span> secondPartIndex=head+(tail-head)/<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//指向后半段的第一个元素</span></span><br><span class="line">	<span class="keyword">int</span> mergeIndex=head;</span><br><span class="line">	<span class="comment">/*核心代码*/</span></span><br><span class="line">	<span class="keyword">for</span>(;mergeIndex&lt;=tail;mergeIndex++)&#123;<span class="comment">//遍历地比较前半段和后半段的元素大小，并赋值到辅助数组里</span></span><br><span class="line">		<span class="keyword">if</span>(firstPartIndex&lt;=head+(tail-head)/<span class="number">2</span>&amp;&amp;secondPartIndex&lt;=tail)&#123;<span class="comment">//如果前半部分和后半部分都还没比完</span></span><br><span class="line">			<span class="keyword">if</span>(sortedData[firstPartIndex]&lt;sortedData[secondPartIndex])&#123;</span><br><span class="line">				tempData[mergeIndex]=sortedData[firstPartIndex];</span><br><span class="line">				firstPartIndex++;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				tempData[mergeIndex]=sortedData[secondPartIndex];</span><br><span class="line">				secondPartIndex++;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(firstPartIndex&lt;=head+(tail-head)/<span class="number">2</span>)&#123;<span class="comment">//如果前半段还有数，而后半段没有了，就把前半段的数全部赋值给辅助数组</span></span><br><span class="line">			<span class="keyword">while</span>(firstPartIndex&lt;=head+(tail-head)/<span class="number">2</span>)&#123;</span><br><span class="line">				tempData[mergeIndex++]=sortedData[firstPartIndex++];<span class="comment">//这里因为是在while循环里，所以mergeIndex也要记得+1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果后半段还有数，而前半段没有了。或者，两者均无。则无需任何操作。</span></span><br><span class="line">		<span class="comment">//为什么后半段还有数，却无需任何操作？</span></span><br><span class="line">		<span class="comment">//后半段如果还有数，按照之前的思路，我们应该先把后半段剩下的数存到tempData，可是所有tempData的数，最后我们还是要赋值给sortedData数组呀。那么，这种情况下，也就意味着当前sortedData中保存的后半段剩余元素的排序是正确的，即无需任何操作.</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head;i&lt;=Math.min(tail,mergeIndex);i++)&#123;</span><br><span class="line">		sortedData[i]=tempData[i];<span class="comment">//把前面得到的辅助函数的值重新赋值给sortedData</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-时间复杂度"><a href="#2-4-3-时间复杂度" class="headerlink" title="2.4.3 时间复杂度"></a>2.4.3 时间复杂度</h4><p>时间复杂度：Θ(nlog<sup>n</sup>)<br>分析：下图中“合并排序”操作对应<code>mergeSort()</code>，“合并”操作对应<code>merge()</code><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.8.jpg?raw=true" alt="@图2.5 合并排序时间复杂度分析"></p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>recursion</tag>
        <tag>Merge sort</tag>
      </tags>
  </entry>
</search>
