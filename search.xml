<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法之10动态规划解决最大子串和问题</title>
    <url>/2020/06/29/%E7%AE%97%E6%B3%95%E4%B9%8B10%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E6%9C%80%E5%A4%A7%E5%AD%90%E4%B8%B2%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="3-动态规划-Dynamic-Programming"><a href="#3-动态规划-Dynamic-Programming" class="headerlink" title="3 动态规划(Dynamic Programming)"></a>3 动态规划(Dynamic Programming)</h2><h3 id="3-1-算法介绍"><a href="#3-1-算法介绍" class="headerlink" title="3.1 算法介绍"></a>3.1 算法介绍</h3><h4 id="3-1-1-动态规划特性"><a href="#3-1-1-动态规划特性" class="headerlink" title="3.1.1 动态规划特性"></a>3.1.1 动态规划特性</h4><blockquote>
<ul>
<li>问题分阶段：一个问题的求解可以拆分成若干个阶段的子问题</li>
<li>阶段有依赖：问题的最优解依赖于子阶段问题的最优解</li>
<li>问题有重复：一个问题的求解过程中，其子问题可能会重复出现</li>
</ul>
</blockquote>
<h4 id="3-1-2-表格法"><a href="#3-1-2-表格法" class="headerlink" title="3.1.2 表格法"></a>3.1.2 表格法</h4><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">适用情形</th>
<th align="center">方向</th>
</tr>
</thead>
<tbody><tr>
<td align="center">求出所有解</td>
<td align="center">要求所有解的情形</td>
<td align="center">自下而上</td>
</tr>
</tbody></table>
<h4 id="3-1-3-备忘录法"><a href="#3-1-3-备忘录法" class="headerlink" title="3.1.3 备忘录法"></a>3.1.3 备忘录法</h4><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">适用情形</th>
<th align="center">方向</th>
<th align="center">实现方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">只求出所需解</td>
<td align="center">无需求出所有解的情况</td>
<td align="center">自上而下</td>
<td align="center">递归</td>
</tr>
</tbody></table>
<h3 id="3-2-最大子串和-Maximum-Subarray"><a href="#3-2-最大子串和-Maximum-Subarray" class="headerlink" title="3.2 最大子串和(Maximum Subarray)"></a>3.2 最大子串和(Maximum Subarray)</h3><h4 id="3-2-1-问题描述"><a href="#3-2-1-问题描述" class="headerlink" title="3.2.1 问题描述"></a>3.2.1 问题描述</h4><p>假设已知未来几天的股票市场价格，规定在这期间只能买卖一次，请问何时买卖才能使获利最大？<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.13.jpg?raw=true" alt=""></p>
<h4 id="3-2-2-算法思路"><a href="#3-2-2-算法思路" class="headerlink" title="3.2.2 算法思路"></a>3.2.2 算法思路</h4><p><strong>整体思路：</strong>假设只有前两天可以买卖，算出一个最大收益，然后继续假设前三天可以买卖，算出最大收益……一直算到最后一天，就算出了我们最终的最大收益。</p>
<p><strong>详细思路：</strong><br>首先看如下这张表，其含义是：</p>
<ul>
<li>第一行表示当天价格和前一天价格的差价</li>
<li>第二行表示当前累计的收益，如果小于0时，则归零。起到辅助第三行的作用</li>
<li>第三行表示最大收益，也就是我们要求的答案</li>
</ul>
<p>问题分阶段：第一列表示，假如只有前两天有买卖机会，最大收益是多少？第二列表示，假如只有前三天的有机会……<br>阶段有依赖：每一次算出的答案都可以依赖于前一次的答案，因此避开了许多重复操作。所谓的依赖，从这张表来看，就是<code>最大收益[i]=max(当前累积[i],最大收益[i-1]),(i&gt;0)</code><br>注意：这里只是为了方便说明，本文的代码中并没有用数组实现，而是直接使用了一个变量进行存储<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.14.jpg?raw=true" alt=""></p>
<p>我们需要做的，就是求出这张表。</p>
<h4 id="3-2-3-代码实现"><a href="#3-2-3-代码实现" class="headerlink" title="3.2.3 代码实现"></a>3.2.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getByDynamicProgramming(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] changes = <span class="keyword">new</span> <span class="keyword">int</span> [prices.length-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;changes.length;i++) &#123;</span><br><span class="line">			changes[i] = prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> maxSum = changes[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> currentMaxSum = changes[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> startIndex =<span class="number">0</span>,endIndex =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> currentIndex=<span class="number">1</span>; currentIndex&lt;changes.length; currentIndex++) &#123;</span><br><span class="line">		<span class="comment">/*核心代码*/</span></span><br><span class="line">			<span class="keyword">if</span>(currentMaxSum&lt;=<span class="number">0</span>) &#123;<span class="comment">//如果累积小于零</span></span><br><span class="line">				currentMaxSum = changes [currentIndex];<span class="comment">//把当前累计设置为价格变化</span></span><br><span class="line">				currentStartIndex = currentIndex;<span class="comment">//暂时保存，直到最大收益值变化，再将其赋值给买入时间</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				currentMaxSum += changes[currentIndex];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(currentMaxSum&gt;maxSum) &#123;<span class="comment">//如果当前累积大于最大收益</span></span><br><span class="line">				maxSum = currentMaxSum;<span class="comment">//把当前累积赋值给最大收益</span></span><br><span class="line">				startIndex = currentStartIndex;</span><br><span class="line">				endIndex = currentIndex;<span class="comment">//设置为这一天买入</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> [] answer = &#123;maxSum, startIndex, endIndex+<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="keyword">return</span> answer;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-算法复杂度"><a href="#3-2-4-算法复杂度" class="headerlink" title="3.2.4 算法复杂度"></a>3.2.4 算法复杂度</h4><p>Θ(n)</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Dynamic Programming</tag>
        <tag>Maximum Subarray</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之11动态规划解决跳跃问题</title>
    <url>/2020/06/29/%E7%AE%97%E6%B3%95%E4%B9%8B11%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="3-3-跳跃问题-Jump-Game"><a href="#3-3-跳跃问题-Jump-Game" class="headerlink" title="3.3 跳跃问题(Jump Game)"></a>3.3 跳跃问题(Jump Game)</h3><h4 id="3-3-1-问题描述"><a href="#3-3-1-问题描述" class="headerlink" title="3.3.1 问题描述"></a>3.3.1 问题描述</h4><p>给定一个非负整数数组，初始状态你在数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。请判断，你最后是否能够抵达最后一个位置？<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.15.jpg?raw=true" alt=""></p>
<h4 id="3-3-2-暴力求解"><a href="#3-3-2-暴力求解" class="headerlink" title="3.3.2 暴力求解"></a>3.3.2 暴力求解</h4><p><strong>算法思路：</strong>设置一个新数组，遍历原数组，把元素能到达的位置都在新数组里标为1，最后看最后一位是否为1。</p>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> [] reachable=<span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</span><br><span class="line">	reachable[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始状态站在数组的第一个位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="comment">/*核心代码*/</span></span><br><span class="line">		<span class="keyword">if</span>(reachable==<span class="number">1</span>)&#123;<span class="comment">//如果前面的位置可以到达当前位置</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nums[i]&amp;&amp;j+i&lt;nums.length;j++)&#123;<span class="comment">//保证数字是多少就走多少步，同时保证不能走越界</span></span><br><span class="line">				reachable[i+j]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums[nums.length-<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<code>O(mn)</code>，n为元素组的元素个数，m为数组内元素值的最大值，也就是每次走的步数的最大值。</p>
<p><strong>缺陷</strong>：子问题存在重复地判断或写入1，导致速度变慢。</p>
<h4 id="3-3-3-动态规划"><a href="#3-3-3-动态规划" class="headerlink" title="3.3.3 动态规划"></a>3.3.3 动态规划</h4><p><strong>算法思路</strong>：如果第i个元素可以到达终点，则在它之前的元素，只要能到达i，就必然能到达终点。本着这个原则，我们把数组的后面往前看，逐个遍历数组元素，如果某个元素可以到达终点，就把它设置为终点，看在它前面的元素能不能到达这里。这样就形成了一个新的子问题，这个子问题跟原问题是一样的。所以我们使用递归的方法实现。<br><strong>动态规划的思想</strong></p>
<ul>
<li>问题分阶段(Multiple stage)：每个子问题的递归就是分阶段的体现</li>
<li>阶段有依赖(Optimal sub-structure)：每一个子问题的都有一个前提，即依赖条件，就是子问题的终点能够到达父问题的终点</li>
<li>依赖有重叠(Overlapping sub-problem)：我们解决了暴力求解中存在的重复操作</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> canJump(nums,nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolea <span class="title">canJumps</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">	<span class="comment">/*核心代码*/</span></span><br><span class="line">	<span class="keyword">if</span>(last==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//如果last指向首元素，则可以到达终点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=last-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">//从后往前遍历查找</span></span><br><span class="line">		<span class="keyword">if</span>(nums[i]+i&gt;=last)&#123;<span class="comment">//如果该元素可以到达终点，则在它前面的元素，只要能到达这里，就必然能到达终点。</span></span><br><span class="line">			<span class="keyword">return</span> canJump(nums,i);<span class="comment">//把该元素设置为终点，开始递归</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：Θ(n)</p>
<h4 id="3-3-4-解法三"><a href="#3-3-4-解法三" class="headerlink" title="3.3.4 解法三"></a>3.3.4 解法三</h4><p><strong>算法思路：</strong>如果数组元素全为正数，则必然可以到达终点。所以问题的本质在于是否可以走过值为0的元素。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=nums.length;</span><br><span class="line">	<span class="keyword">int</span> zeroPoint=-<span class="number">1</span>;<span class="comment">//指出值为0的元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;<span class="comment">//如果元素值为0</span></span><br><span class="line">			<span class="keyword">if</span>(zeroPoint==-<span class="number">1</span>)&#123;<span class="comment">//如果该元素前面没有不可越过的0点</span></span><br><span class="line">				zeroPoint =i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(zeroPoint!=-<span class="number">1</span>)&#123;<span class="comment">//前面存在不可越过的0点</span></span><br><span class="line">			<span class="keyword">if</span>(i+nums[i]&gt;zeroPoint)&#123;<span class="comment">//判断这个点能否越过0点</span></span><br><span class="line">				zeroPoint=-<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> zeroPoint==-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Dynamic Programming</tag>
        <tag>Jump Game</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之3分治法解决全排列问题</title>
    <url>/2020/06/22/%E7%AE%97%E6%B3%95%E4%B9%8B3%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="2-3-1-问题描述"><a href="#2-3-1-问题描述" class="headerlink" title="2.3.1 问题描述"></a>2.3.1 问题描述</h4><p> 给出n个元素的所有可能的排列方式。<br> 如: [1,2,3]的排列有[1,2,3], [1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]</p>
<h4 id="2-3-2-问题解决"><a href="#2-3-2-问题解决" class="headerlink" title="2.3.2 问题解决"></a>2.3.2 问题解决</h4><p>我们最开始有一个nums数组，我们首先从第一位开始排，第一位的值有三种可能，我们先设置一个变量start_index=0，它表示我们目前排到了第几位，然后分别让nums[start_index]和后面几位的元素交换位置，每交换好一次，就确定了那一位的值，然后开始往下一位继续递归，递归完毕后需要恢复到原来的位置，再让nums[start_index]和下一位交换位置。<br>总结来说就是三个步骤：</p>
<ul>
<li>① 交换元素位置</li>
<li>② 递归</li>
<li>③ 恢复元素位置</li>
</ul>
<p>所以整个全排列的实现，其实是按照图中箭头的顺序实现的，向下的箭头都是<strong>交换元素位置</strong>，向上的箭头则是<strong>恢复元素位置</strong>。<br><strong>你可能会不理解为什么要交换和恢复元素位置？</strong><br>简单来说就是，第一位可能是1、2、3三种可能，1和1交换得出1xx排列，1和2交换得出2xx排列，1和3换得出3xx排列。比如2xx的全部排完就是递归结束了，现在得把1和2的位置恢复回来，这样才能保证待会儿1和3交换。如果不恢复位置，就会变成2和3交换了，那就和我们的本意违背了。<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.5.jpg?raw=true" alt="@图2.2 以3个元素为例分析排列问题的示意图"></p>
<h4 id="2-3-3-代码实现"><a href="#2-3-3-代码实现" class="headerlink" title="2.3.3 代码实现"></a>2.3.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">int</span>[]&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">	List&lt;<span class="keyword">int</span>[]&gt; perms=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//保存全排列</span></span><br><span class="line">	permute_recursion(nums,<span class="number">0</span>,perms);</span><br><span class="line">	<span class="keyword">return</span> perms;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permute_recurison</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start_index,List&lt;<span class="keyword">int</span>[]&gt; list)</span></span>&#123;<span class="comment">//参数含义：nums-待排序数组，start_index-排序起始位置，list-全排列</span></span><br><span class="line">	<span class="keyword">int</span> len=nums.length;</span><br><span class="line">	<span class="keyword">if</span>(start_index==len-<span class="number">1</span>)&#123;<span class="comment">//如果排到最后一位，则停止递归，直接加入list</span></span><br><span class="line">		<span class="keyword">int</span> [] perm=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			perm[i]=nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		list.add(perm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">/*核心代码：不断交换位置、递归、恢复位置*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=start_index;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			swap(nums,start_index,i);<span class="comment">//交换nums[start_index]和nums[i]</span></span><br><span class="line">			permute_recursion(nums,start_index+<span class="number">1</span>,list);<span class="comment">//从start_index+1开始递归寻找全排列</span></span><br><span class="line">			swap(nums,start_index,i);<span class="comment">//还原nums[start_index]和nums[i]</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//swap：交换数组的两个元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums ,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=nums[i];</span><br><span class="line">	nums[i]=nums[j];</span><br><span class="line">	nums[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-时间复杂度"><a href="#2-3-4-时间复杂度" class="headerlink" title="2.3.4 时间复杂度"></a>2.3.4 时间复杂度</h4><p>时间复杂度：<code>Ω(n!)</code><br>分析：<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.6.jpg?raw=true" alt="@图2.3 以3个元素为例分析排列问题的时间复杂度"><br>第一层，for循环要执行三次，每次执行都要调用两次swap()函数和一次递归，所以为3+3x3<br>第二层，for循环要执行两次，也是每次执行都要调用两次swap()函数和一次递归，但因为这里有三个分支（分别为1xx、2xx、3xx），所以为(2+2x2)x3<br>…<br>最后一层，不需要执行for循环，有3!个分支，所以是3!<br>同样的分析方法，我们可以得出n个元素的情况，结果见图片。因为最后一层是n!，所以知道时间复杂度的下限为Ω(n!)</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>recursion</tag>
        <tag>Permute</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之5分治法实现合并排序</title>
    <url>/2020/06/23/%E7%AE%97%E6%B3%95%E4%B9%8B5%E5%88%86%E6%B2%BB%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="2-5-合并排序-merge-sort"><a href="#2-5-合并排序-merge-sort" class="headerlink" title="2.5 合并排序(merge sort)"></a>2.5 合并排序(merge sort)</h3><h4 id="2-5-1-算法思路"><a href="#2-5-1-算法思路" class="headerlink" title="2.5.1 算法思路"></a>2.5.1 算法思路</h4><p>总体步骤：</p>
<ul>
<li>① 拆分</li>
<li>② 合并，边合并边排序</li>
</ul>
<p><em>详细的解释在2.5.2代码注释中</em><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.7.jpg?raw=true" alt="@图2.4 合并排序示意图"></p>
<h4 id="2-5-2-代码及注释"><a href="#2-5-2-代码及注释" class="headerlink" title="2.5.2 代码及注释"></a>2.5.2 代码及注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] originalData)&#123;</span><br><span class="line">	<span class="keyword">int</span> [] sortedData=originalData.clone;<span class="comment">//拷贝一份原数组，用来存排好序的数组</span></span><br><span class="line">	<span class="keyword">int</span> [] tempData=originalData.clone;<span class="comment">//辅助数组，用来保存排序好的一部分数组，</span></span><br><span class="line">	mergeSort(SortedData,<span class="number">0</span>,sortedData.length-<span class="number">1</span>,tempData);</span><br><span class="line">	<span class="keyword">return</span> SortedData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] sortedData,<span class="keyword">int</span> head,<span class="keyword">int</span> tail,<span class="keyword">int</span>[] tempData)</span></span>&#123;</span><br><span class="line">	<span class="comment">/*较为重要的代码*/</span></span><br><span class="line">	<span class="keyword">if</span>(head==tail)<span class="keyword">return</span>;<span class="comment">//拆分到只剩一个元素时</span></span><br><span class="line">	mergeSort(sortedData,head,head+(tail-head)/<span class="number">2</span>,tempData);<span class="comment">//前半段</span></span><br><span class="line">	mergeSort(sortedData,head+(tail-head)/<span class="number">2</span>+<span class="number">1</span>,tail,tempData);<span class="comment">//后半段</span></span><br><span class="line">	merge(sortedData,head,tail,tempData);<span class="comment">//合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] sortedData,<span class="keyword">int</span> head,<span class="keyword">int</span> tail,<span class="keyword">int</span>[] tempData)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> firstPartIndex=head;<span class="comment">//指向前半段的第一个元素</span></span><br><span class="line">	<span class="keyword">int</span> secondPartIndex=head+(tail-head)/<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//指向后半段的第一个元素</span></span><br><span class="line">	<span class="keyword">int</span> mergeIndex=head;</span><br><span class="line">	<span class="comment">/*核心代码*/</span></span><br><span class="line">	<span class="keyword">for</span>(;mergeIndex&lt;=tail;mergeIndex++)&#123;<span class="comment">//遍历地比较前半段和后半段的元素大小，并赋值到辅助数组里</span></span><br><span class="line">		<span class="keyword">if</span>(firstPartIndex&lt;=head+(tail-head)/<span class="number">2</span>&amp;&amp;secondPartIndex&lt;=tail)&#123;<span class="comment">//如果前半部分和后半部分都还没比完</span></span><br><span class="line">			<span class="keyword">if</span>(sortedData[firstPartIndex]&lt;sortedData[secondPartIndex])&#123;</span><br><span class="line">				tempData[mergeIndex]=sortedData[firstPartIndex];</span><br><span class="line">				firstPartIndex++;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				tempData[mergeIndex]=sortedData[secondPartIndex];</span><br><span class="line">				secondPartIndex++;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(firstPartIndex&lt;=head+(tail-head)/<span class="number">2</span>)&#123;<span class="comment">//如果前半段还有数，而后半段没有了，就把前半段的数全部赋值给辅助数组</span></span><br><span class="line">			<span class="keyword">while</span>(firstPartIndex&lt;=head+(tail-head)/<span class="number">2</span>)&#123;</span><br><span class="line">				tempData[mergeIndex++]=sortedData[firstPartIndex++];<span class="comment">//这里因为是在while循环里，所以mergeIndex也要记得+1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果后半段还有数，而前半段没有了。或者，两者均无。则无需任何操作。</span></span><br><span class="line">		<span class="comment">//为什么后半段还有数，却无需任何操作？</span></span><br><span class="line">		<span class="comment">//后半段如果还有数，按照之前的思路，我们应该先把后半段剩下的数存到tempData，可是所有tempData的数，最后我们还是要赋值给sortedData数组呀。那么，这种情况下，也就意味着当前sortedData中保存的后半段剩余元素的排序是正确的，即无需任何操作.</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head;i&lt;=Math.min(tail,mergeIndex);i++)&#123;</span><br><span class="line">		sortedData[i]=tempData[i];<span class="comment">//把前面得到的辅助函数的值重新赋值给sortedData</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-时间复杂度"><a href="#2-4-3-时间复杂度" class="headerlink" title="2.4.3 时间复杂度"></a>2.4.3 时间复杂度</h4><p>时间复杂度：Θ(nlog<sub>2</sub>n)<br>分析：下图中“合并排序”操作对应<code>mergeSort()</code>，“合并”操作对应<code>merge()</code><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.8.jpg?raw=true" alt="@图2.5 合并排序时间复杂度分析"></p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>recursion</tag>
        <tag>Merge sort</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之2分治法解决汉诺塔问题</title>
    <url>/2020/06/22/%E7%AE%97%E6%B3%95%E4%B9%8B2%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%A3%E5%86%B3%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="2-递归与分治策略"><a href="#2-递归与分治策略" class="headerlink" title="2 递归与分治策略"></a>2 递归与分治策略</h2><h3 id="2-1-算法介绍"><a href="#2-1-算法介绍" class="headerlink" title="2.1 算法介绍"></a>2.1 算法介绍</h3><p><strong>分治法</strong>(Divide and conquer)：将一个规模较大问题分解为规模较小的子问题，先求解这些子问题，然后将各子问题的解合并得到原问题的解的算法思路。</p>
<p><strong>递归</strong>(Recursion)：直接或间接地调用自身的算法。</p>
<ul>
<li>优点：<ul>
<li>是一种自然的思考方式</li>
<li>思路清晰</li>
<li>易于实现</li>
</ul>
</li>
<li>缺点：<ul>
<li>具体执行步骤难以理解</li>
<li>坏的递归大幅提高算法复杂度</li>
</ul>
</li>
</ul>
<p><strong>分治与递归的联系</strong>：分治法的子问题通常与原问题结构和求解方法相同，可以通过<em>递归</em>的方法求解。</p>
<h3 id="2-2-汉诺塔-Hanoi-tower"><a href="#2-2-汉诺塔-Hanoi-tower" class="headerlink" title="2.2 汉诺塔(Hanoi tower)"></a>2.2 汉诺塔(Hanoi tower)</h3><h4 id="2-2-1-问题描述"><a href="#2-2-1-问题描述" class="headerlink" title="2.2.1 问题描述"></a>2.2.1 问题描述</h4><p>有3根柱子及n个不同大小的圆盘，最初，所有盘子由上到下、从小到大地套在第一根柱子上。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。<br>请问：将所有盘子从第一根柱子移到最后一根柱子，如何移动才能移动次数最少？需要移动多少次？</p>
<h4 id="2-2-2-问题解决"><a href="#2-2-2-问题解决" class="headerlink" title="2.2.2 问题解决"></a>2.2.2 问题解决</h4><p>令三个柱子分别为A、B、C，最初所有的盘子都在A上，从宏观上看，要想把A的盘子全部移动到C，则可以：</p>
<ul>
<li>① 将n-1个盘子从A移到B</li>
<li>② 将最下面的1个盘子从A移到C</li>
<li>③ 将n-1个盘子从B移动到C</li>
</ul>
<p>你可能会问，问题要求(1)中明明限制了一次只能移动一个盘子！<br>这个时候就要用到分治和递归的思想，上述三个步骤中，仅有步骤②是直接执行，其中步骤①和步骤③都要通过递归实现。<br>我们先说步骤①，如何把n-1个盘子从A移到B？这可以看成一个新的子问题，而这个子问题跟原问题是一样的，所以我们可以利用递归，再次重复上述的三个步骤就行了，但是，要如何设置参数呢？首先，这个子问题中只有n-1个盘子，所以我们只需要把n改为n-1，其次，要想把n-1个盘子从A移到B，就得先把n-2个盘子从A移到C，依次类推往下…..<br>请你注意：在不断递归的过程中，A、B、C的“移动角色”在不断改变，原问题是把n个盘子从A移到C，子问题为把n-1个盘子从A移到B，子子问题是把n-2个盘子从A移到C…<br>步骤③的原理同步骤②。</p>
<p>建议这段讲解，配合代码一起阅读，将有助于理解。</p>
<h4 id="2-2-3-时间复杂度"><a href="#2-2-3-时间复杂度" class="headerlink" title="2.2.3 时间复杂度"></a>2.2.3 时间复杂度</h4><p>时间复杂度：O(2<sup>n</sup>)<br>分析：<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.4.jpg?raw=true" alt="@图2.1 以五个圆盘为例的时间复杂度分析示意图"><br>我们首先以5个圆盘为例，来分析时间复杂度。<br>这张图的含义：灰色部分为直接执行的步骤②，黄色部分为递归执行的步骤①和③。圆圈内的数字代表圆盘的个数，圆圈旁的数字代表所需执行的步骤数，左侧的式子代表对应一层的执行步骤数。<br>这张图的分析：我们从左侧的式子中可以看出，n=5时，就把每一层的执行步骤数加起来，就是总的执行步骤数，为3+7x2<sup>0</sup>+7x2<sup>1</sup>+7x2<sup>2</sup>+6x2<sup>2</sup><br>推广至n时，则为3+(2<sup>0</sup>+2<sup>1</sup>+…+2<sup>n-3</sup>)+6x2<sup>2</sup>=2.5x2<sup>n</sup>-4,故O(2<sup>n</sup>)</p>
<h4 id="2-2-3-代码实现"><a href="#2-2-3-代码实现" class="headerlink" title="2.2.3 代码实现"></a>2.2.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HanoiSimple</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(Tower A,Tower B,Tower C)</span></span>&#123;</span><br><span class="line">		move(A.size(),A,B,C);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,Tower A,Tower B,Tower C)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;<span class="comment">//终止，只剩一个盘子</span></span><br><span class="line">			C.add(A.remove());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">		    <span class="comment">/*关键代码：实现递归与分治*/</span></span><br><span class="line">			move(n-<span class="number">1</span>,A,C,B);<span class="comment">//将n-1个盘子从A移到B(继续递归)</span></span><br><span class="line">			move(<span class="number">1</span>,A,B,C);<span class="comment">//将最下面的那个盘子从A移到C(真正执行)</span></span><br><span class="line">			move(n-<span class="number">1</span>,B,A,C);<span class="comment">//将n-1个盘子从B移动到C(继续递归)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>Hanoi tower</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之4选择排序</title>
    <url>/2020/06/23/%E7%AE%97%E6%B3%95%E4%B9%8B4%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="2-4-1-算法思路"><a href="#2-4-1-算法思路" class="headerlink" title="2.4.1 算法思路"></a>2.4.1 算法思路</h4><p><em>此方法为暴力求解，在此非重点。</em><br>首先选择第一个元素，初始化minIndex=0，然后从第二个元素开始从左往右遍历，找出右边比sortedData[minIndex]更小的元素，就将其序号赋值给minIndex，遍历完右边的所有元素后，交换第i个元素和第minIndex元素。<br>然后选择第二个元素，从第三个元素开始从左往右遍历，其余步骤同上。</p>
<h4 id="2-4-2-代码实现"><a href="#2-4-2-代码实现" class="headerlink" title="2.4.2 代码实现"></a>2.4.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] originalData)&#123;</span><br><span class="line">	<span class="keyword">int</span> [] sortedData=originalData.clone();<span class="comment">//复制一份原始数据，用来保存排序好的数组</span></span><br><span class="line">	<span class="comment">/*核心代码*/</span></span><br><span class="line">	<span class="comment">//注意：这里i取到sortedData.length-2就能保证排序好</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sortedData.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> minIndex=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;sortedData.length;j++)&#123;<span class="comment">//j必须遍历到最后一位</span></span><br><span class="line">			<span class="keyword">if</span>(sortedData[minIndex]&gt;sortedDate[j])&#123;<span class="comment">//如果大于最小值，则将索引保存到minIndex</span></span><br><span class="line">				minIndex=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(sortedData,i,minIndex);<span class="comment">//将i和minIndex的元素交换</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sortedData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-时间复杂度"><a href="#2-4-3-时间复杂度" class="headerlink" title="2.4.3 时间复杂度"></a>2.4.3 时间复杂度</h4><p>时间复杂度：Θ(n<sup>2</sup>)<br>分析：(n-1)+(n-2)+(n-3)+….1=n(n-1)/2</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Selection sort</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之6分治法实现快速排序</title>
    <url>/2020/06/28/%E7%AE%97%E6%B3%95%E4%B9%8B6%E5%88%86%E6%B2%BB%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="2-6-快速排序-quick-sort"><a href="#2-6-快速排序-quick-sort" class="headerlink" title="2.6 快速排序(quick sort)"></a>2.6 快速排序(quick sort)</h3><h4 id="2-6-1-算法思路"><a href="#2-6-1-算法思路" class="headerlink" title="2.6.1 算法思路"></a>2.6.1 算法思路</h4><p><strong>整体思路：</strong>随机选一个数，把比它大的数放在它的右边，小的放在左边，那个数所在的位置，就会是它最终排序所在的位置。然后继续排左右两边的数，按这种思路往下递归。</p>
<p><strong>细节步骤：</strong>随机选择的那个数，我们称之为“基准数”。</p>
<ul>
<li>① 设置基准数。随机选择一个数为基准数，把基准数和首元素交换位置</li>
<li>② 移动指针。设置左指针和右指针，左指针从左往右移动，一旦找到比基准数大的元素就停下来，然后左指针从右往左移动，一旦找到比基准数小的元素就停下来，然后把它俩互换位置，同理，左右指针继续向中间移动，直到两个指针重合或者错位</li>
<li>③ 插入基准数。基准数如果比右指针的元素小，就把基准数和右指针的左边一个元素互换位置，如果基准数比右指针的元素大，就把基准数和<strong>尾</strong>指针元素互换。</li>
<li>④ 递归。基准数的左右两部分继续进行排序。</li>
</ul>
<p>请问，步骤④中：</p>
<ul>
<li>当基准数比右指针的元素小，为什么不可以是把基准数和左指针交换？</li>
<li>基准数如果比右指针元素大，为什么是把基准数和尾指针元素互换？</li>
<li>基准数如果比右指针元素大，是否可以把基准数和右指针右边的一个数交换?</li>
</ul>
<p>回答：</p>
<ul>
<li>1.因为左右指针可能位置重合。</li>
<li>2.(看代码)但凡右指针有移动过，则右指针所指元素必然大于等于基准元素，如果右指针元素小于基准元素，则说明右指针必然没有移动过，此时右指针跟尾指针重合。如果右指针元素等于基准元素，意味着右指针及其右侧的元素(如果存在的话)都必然等于基准元素，所以直接把基准元素跟尾指针元素互换，没有问题。</li>
<li>3.不可以，若右指针是尾指针，其右侧将发生越界。</li>
</ul>
<h4 id="2-6-2-代码实现"><a href="#2-6-2-代码实现" class="headerlink" title="2.6.2 代码实现"></a>2.6.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] originalData) &#123;</span><br><span class="line">	<span class="keyword">int</span> [] sortedData=originalData.clone();</span><br><span class="line">	QSRecursion(sortedData,<span class="number">0</span>,sortedData.length-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> sortedData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QSRecursion</span><span class="params">(<span class="keyword">int</span>[] sortedData, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==tail)<span class="keyword">return</span>;<span class="comment">//如果只有一个元素，则无需排序</span></span><br><span class="line">	<span class="keyword">int</span> partitionIndex=head+<span class="keyword">new</span> java.util.Random().nextInt(tail-head+<span class="number">1</span>);<span class="comment">//随机选择一个数，设置为基准元素</span></span><br><span class="line">	<span class="keyword">int</span> pivot=partition(sortedData,head,tail,partitionIndex);<span class="comment">//保存基准元素排好的位置</span></span><br><span class="line">	<span class="keyword">if</span>(pivot!=head)QSRecursion(sortedData,head,pivot-<span class="number">1</span>);<span class="comment">//如果基准元素不在第一位，则继续将其左边的序列进行排序</span></span><br><span class="line">	<span class="keyword">if</span>(pivot!=tail)QSRecursion(sortedData,pivot+<span class="number">1</span>,tail);<span class="comment">//如果基准元素不在最后一位，则继续将其右边的序列进行排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] sortedData, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> partitionIndex)</span> </span>&#123;</span><br><span class="line">	swap(sortedData,head,partitionIndex);<span class="comment">//将首元素和基准元素对换位置</span></span><br><span class="line">	<span class="keyword">int</span> left=head+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> right=tail;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">		<span class="keyword">while</span>(sortedData[left]&lt;=sortedData[head]&amp;left&lt;right) &#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(sortedData[right]&gt;=sortedData[head]&amp;left&lt;right) &#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">			swap(sortedData,right,left);<span class="comment">//对换位置,保证左小右大</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*核心代码，易错点*/</span></span><br><span class="line">	<span class="keyword">if</span>(sortedData[right]&gt;sortedData[head]) &#123;</span><br><span class="line">		swap(sortedData,right-<span class="number">1</span>,head);</span><br><span class="line">		partitionIndex=right-<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		swap(sortedData,tail,head);</span><br><span class="line">		partitionIndex=tail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> partitionIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-3-时间复杂度"><a href="#2-6-3-时间复杂度" class="headerlink" title="2.6.3 时间复杂度"></a>2.6.3 时间复杂度</h4><p><strong>最坏情形</strong>：Θ(n<sup>2</sup>）<br>分析：最坏情形类似于选择排序，就是每次选择的基准数都是最大或者最小的数，此时快速排序每一次递归，需要比较n次，n次递归后才排好所有的数，所以最坏情形的时间复杂度n<sup>2</sup>。<br><strong>最好情形</strong>：Θ(nlog<sub>2</sub>n)<br>分析：最好情形类似于合并排序，就是每次选择的基准数都是中位数，此时快速排序每一次递归，需要比较n次，log<sub>2</sub>n次递归后排好所有的数，所以最好情形的时间复杂度nlog<sub>2</sub>n。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>recursion</tag>
        <tag>Quick sort</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之7分治法利用快速排序实现寻找第K最小数</title>
    <url>/2020/06/28/%E7%AE%97%E6%B3%95%E4%B9%8B7%E5%88%86%E6%B2%BB%E6%B3%95%E5%88%A9%E7%94%A8%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%AF%BB%E6%89%BE%E7%AC%ACK%E6%9C%80%E5%B0%8F%E6%95%B0/</url>
    <content><![CDATA[<h3 id="2-7-寻找第K最小数"><a href="#2-7-寻找第K最小数" class="headerlink" title="2.7 寻找第K最小数"></a>2.7 寻找第K最小数</h3><h4 id="2-7-1-算法思路"><a href="#2-7-1-算法思路" class="headerlink" title="2.7.1 算法思路"></a>2.7.1 算法思路</h4><p><strong>整体思路：</strong>结合2.6节的快速排序</p>
<ul>
<li>如果基准位就是第k位，就直接返回</li>
<li>如果基准位在k的左端，就从基准位到尾部找</li>
<li>如果基准位在k的右端，就从首部到基准位找</li>
</ul>
<h4 id="2-7-2-代码实现"><a href="#2-7-2-代码实现" class="headerlink" title="2.7.2 代码实现"></a>2.7.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKthSmallByDivideConquer</span><span class="params">(<span class="keyword">int</span>[] originalData, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] sortedData=originalData.clone();</span><br><span class="line">		<span class="keyword">return</span> sortedData[getKthSmallByDivideConquer(sortedData,<span class="number">0</span>,sortedData.length-<span class="number">1</span>,k)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKthSmallByDivideConquer</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head==tail) &#123;<span class="comment">//只有一个数的情况</span></span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> partitionIndex=head+<span class="keyword">new</span> java.util.Random().nextInt(tail-head+<span class="number">1</span>);</span><br><span class="line">			partitionIndex=partition(data,head,tail,partitionIndex);<span class="comment">//调用快速排序</span></span><br><span class="line">			<span class="comment">/*核心代码*/</span></span><br><span class="line">			<span class="keyword">if</span>(partitionIndex&lt;k-<span class="number">1</span>) &#123;<span class="comment">//注意：第k最小数代表0，1，2，...k，即包括0</span></span><br><span class="line">				<span class="keyword">return</span> getKthSmallByDivideConquer(data,partitionIndex+<span class="number">1</span>,tail,k);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(partitionIndex&gt;k-<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> getKthSmallByDivideConquer(data,head,partitionIndex-<span class="number">1</span>,k);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> partitionIndex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">////////////////////////</span></span><br><span class="line"><span class="comment">//给基准位排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] sortedData, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> partitionIndex)</span> </span>&#123;</span><br><span class="line">		swap(sortedData,head,partitionIndex);<span class="comment">//将首元素和基准元素对换位置</span></span><br><span class="line">		<span class="keyword">int</span> left=head+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> right=tail;</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">			<span class="keyword">while</span>(sortedData[left]&lt;=sortedData[head]&amp;left&lt;right) &#123;</span><br><span class="line">				left++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(sortedData[right]&gt;=sortedData[head]&amp;left&lt;right) &#123;</span><br><span class="line">				right--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">				swap(sortedData,right,left);<span class="comment">//对换位置,保证左小右大</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*核心代码，易错点*/</span></span><br><span class="line">		<span class="keyword">if</span>(sortedData[right]&gt;sortedData[head]) &#123;</span><br><span class="line">			swap(sortedData,right-<span class="number">1</span>,head);</span><br><span class="line">			partitionIndex=right-<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			swap(sortedData,tail,head);</span><br><span class="line">			partitionIndex=tail;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> partitionIndex;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">///////////////////////////////	</span></span><br><span class="line"><span class="comment">//交换元素位置</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] sortedData, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=sortedData[a];</span><br><span class="line">		sortedData[a]=sortedData[b];</span><br><span class="line">		sortedData[b]=temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-3-时间复杂度"><a href="#2-7-3-时间复杂度" class="headerlink" title="2.7.3 时间复杂度"></a>2.7.3 时间复杂度</h4><p>时间复杂度：O(nlog<sub>2</sub>n)<br>分析：因为其原理实质为快速排序，所以时间复杂度和快速排序一样。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>recursion</tag>
        <tag>Quick sort</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之9分治法详解二维最近点对问题</title>
    <url>/2020/06/29/%E7%AE%97%E6%B3%95%E4%B9%8B9%E5%88%86%E6%B2%BB%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BA%8C%E7%BB%B4%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="2-9-二维最近点对问题"><a href="#2-9-二维最近点对问题" class="headerlink" title="2.9 二维最近点对问题"></a>2.9 二维最近点对问题</h3><h4 id="2-9-1-问题描述"><a href="#2-9-1-问题描述" class="headerlink" title="2.9.1 问题描述"></a>2.9.1 问题描述</h4><p>问题描述：二维平面上有n个点，如何找到距离最近的点？<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.10.jpg?raw=true" alt=""></p>
<h4 id="2-9-2-暴力求解"><a href="#2-9-2-暴力求解" class="headerlink" title="2.9.2 暴力求解"></a>2.9.2 暴力求解</h4><h5 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1 算法思路"></a>1 算法思路</h5><p>二维平面上有n个点，则有<code>(n-1)+(n-1)+...+1=n(n-1)/2</code>个点对，依次遍历求出所有点对的距离即可。</p>
<h5 id="2-时间复杂度分析"><a href="#2-时间复杂度分析" class="headerlink" title="2 时间复杂度分析"></a>2 时间复杂度分析</h5><p>由1分析可知，即总共要求出<code>n(n-1)/2</code>个距离，故时间复杂度<code>O(n^2)</code></p>
<h4 id="2-9-3-分治法求解"><a href="#2-9-3-分治法求解" class="headerlink" title="2.9.3 分治法求解"></a>2.9.3 分治法求解</h4><h5 id="1-算法思路-1"><a href="#1-算法思路-1" class="headerlink" title="1 算法思路"></a>1 算法思路</h5><p><strong>核心思想：</strong></p>
<ul>
<li>数据预处理</li>
<li>划分中轴线</li>
<li>求出左边的最小距离</li>
<li>求出右半边的最小距离</li>
<li>求出中间的最小距离</li>
<li>比较这三个最小距离</li>
</ul>
<p><strong>① 数据预处理</strong><br>因为这些点的位置是随机产生并保存在二维数组中，所以我们得先将这些点，按照x坐标从小到大<em>排序</em>，调整它们在二维数组中的次序。比如：最左边的点，它的位置就保存在二维数组的第一个元素中；</p>
<p><strong>② 划分中轴线</strong><br>把这些点在平面上分成左右两边。<br>问：依据什么来划分中轴线？<br>答：选择最中间的两个元素，求出它俩x坐标的平均值，设置为中轴线的坐标。</p>
<p><strong>③ 求半边最小距离</strong><br>左半边和右半边的求最小距离的方法是一样的。<br>假如我们现在求的是左半边，那就把左半边也看成一个整体，我们再把它分成左右两半，依次往下递归，越分越小。<br>问：递归何时中止？<br>答：分到点只剩很小的时候就终止，比如本文在后面附加的代码中，是当平面只剩下4个点时就不再切分。</p>
<p><strong>④ 求中间的最小距离</strong><br>问：中间区域应该划分多宽？<br>答：我们只需要考查中轴线左右两边距离小于d的点。理由是，距离中轴线大于d的那些点，它们和另一个半边的点的距离，肯定大于d，考查他们就没有意义了。<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/2.11.jpg?raw=true" alt=""><br>那么，现在我们只需要对上图的左侧2个点和右侧4个点分别进行比较即可。</p>
<p><strong>如何进一步优化？</strong><br>比如我们现在选取了左侧的m点，但实际上，我们不必跟右侧的4个点都比较，只需跟右侧的阴影部分(d*2d)以内的点进行比较，也就是，跟m点垂直距离在d以内的那两个点。<br>原因：如果两点之间垂直距离大于d，那么这两点间距必然大于d，考查他们也没有意义。<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/2.12.jpg?raw=true" alt=""></p>
<p><strong>关于矩形的进一步说明</strong><br>如果查阅过其他资料，或许你听过，我们划分出的dx2d区域中，最多只能有6个点。<br>因为我们已知两侧的最小距离为d，而d*2d的区域中的点是同一侧的。因此这些点的距离必然大于等于d，经过数学几何知识，我们可以算出这个区域最多只能有6个点。</p>
<h5 id="2-时间复杂度分析-1"><a href="#2-时间复杂度分析-1" class="headerlink" title="2 时间复杂度分析"></a>2 时间复杂度分析</h5><p>时间复杂度：O(nlog<sub>2</sub>n)</p>
<h4 id="2-9-4-代码实现"><a href="#2-9-4-代码实现" class="headerlink" title="2.9.4 代码实现"></a>2.9.4 代码实现</h4><p><strong>① 数据预处理</strong><br>在这里，我是采用了效率较高的<strong>快速排序</strong>算法。<br>具体的代码，请见2.6.2节快速排序</p>
<p><strong>② 分治法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getByDivideConquer</span><span class="params">(<span class="keyword">double</span>[][] points)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(points.length==<span class="number">1</span>|points.length==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span>[][] pointsSorted=quickSort(points);</span><br><span class="line">	<span class="keyword">int</span> head=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tail=pointsSorted.length-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> [] minIndex=getByDivideConquer(pointsSorted,head,tail);</span><br><span class="line">	<span class="keyword">double</span> minDist=getDistance(pointsSorted,minIndex[<span class="number">0</span>],minIndex[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> minDist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getByDivideConquer(<span class="keyword">double</span>[][] points, <span class="keyword">int</span> head, <span class="keyword">int</span> tail) &#123;</span><br><span class="line">	<span class="keyword">double</span> minDist=getDistance(points,head,head+<span class="number">1</span>);<span class="comment">//初始化最小距离</span></span><br><span class="line">	<span class="keyword">int</span> [] minIndex=<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;head,head+<span class="number">1</span>&#125;;<span class="comment">//初始化最小点对序号</span></span><br><span class="line">	<span class="keyword">if</span>(tail-head+<span class="number">1</span>&lt;=<span class="number">4</span>) &#123;<span class="comment">//点数小于等于4时</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head;i&lt;=tail-<span class="number">1</span>;i++) &#123;<span class="comment">//遍历求距离</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=tail;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(getDistance(points,i,j)&lt;minDist) &#123;</span><br><span class="line">				<span class="comment">/*核心代码*/</span></span><br><span class="line">					minDist=getDistance(points,i,j);</span><br><span class="line">					minIndex[<span class="number">0</span>]=i;</span><br><span class="line">					minIndex[<span class="number">1</span>]=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> [] minIndexLeft=getByDivideConquer(points,head,head+(tail-head)/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">int</span> [] minIndexRight=getByDivideConquer(points,head+(tail-head)/<span class="number">2</span>+<span class="number">1</span>,tail);</span><br><span class="line">		<span class="keyword">double</span> minDisLeft=getDistance(points,minIndexLeft[<span class="number">0</span>],minIndexLeft[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">double</span> minDisRight=getDistance(points,minIndexRight[<span class="number">0</span>],minIndexRight[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">double</span> minDisTwoSide=Math.min(minDisLeft, minDisRight);<span class="comment">//即d</span></span><br><span class="line">		<span class="keyword">if</span>(minDisLeft&gt;=minDisRight) &#123;</span><br><span class="line">			minDist=minDisRight;</span><br><span class="line">			minIndex=minIndexRight;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			minDist=minDisLeft;</span><br><span class="line">			minIndex=minIndexLeft;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">double</span> middleAxis=(points[head+(tail-head)/<span class="number">2</span>][<span class="number">0</span>]+points[head+(tail-head)/<span class="number">2</span>+<span class="number">1</span>][<span class="number">0</span>])/<span class="number">2</span>;<span class="comment">//设置中间线，该变量为中间线的x轴坐标</span></span><br><span class="line">		<span class="keyword">int</span> i=head+(tail-head)/<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//中间线右边的点</span></span><br><span class="line">		<span class="comment">/*核心代码*/</span></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=tail&amp;&amp;(points[i][<span class="number">0</span>]-middleAxis&lt;minDisTwoSide)) &#123;<span class="comment">//i点没越界且和中间线的x轴距离小于d</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=head+(tail-head)/<span class="number">2</span>;j&gt;=head&amp;&amp;(points[j][<span class="number">0</span>]-middleAxis&lt;minDisTwoSide)&amp;&amp;(count&lt;=<span class="number">6</span>);j--) &#123;<span class="comment">//j点没越界且符合条件的个数小于6</span></span><br><span class="line">					<span class="keyword">if</span>(Math.abs(points[][<span class="number">1</span>]-points[j][<span class="number">1</span>])&lt;minDisTwoSide) &#123;<span class="comment">//找出d*2d矩形的点</span></span><br><span class="line">						<span class="keyword">if</span>(getDistance(points,i,j)&lt;minDist) &#123;</span><br><span class="line">							minDist=getDistance(points,i,j);</span><br><span class="line">							minIndex[<span class="number">0</span>]=i;</span><br><span class="line">							minIndex[<span class="number">1</span>]=j;</span><br><span class="line">						&#125;</span><br><span class="line">					count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minIndex ;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">/////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//计算点i和点j的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">double</span>[][] points, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> dis=Math.sqrt(Math.pow(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>], <span class="number">2</span>)+Math.pow(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>], <span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>1 算法设计与分析之导学</title>
    <url>/2020/06/22/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B1%E5%AF%BC%E5%AD%A6/</url>
    <content><![CDATA[<p>  本博文简单介绍了算法的相关概念(包括：算法设计模式、算法性质、描述方式、评价方法等)以及时间复杂度分析。</p>
<h2 id="1-导学"><a href="#1-导学" class="headerlink" title="1 导学"></a>1 导学</h2><h3 id="1-1-算法的基本概念"><a href="#1-1-算法的基本概念" class="headerlink" title="1.1 算法的基本概念"></a>1.1 算法的基本概念</h3><p><strong>算法设计模式：</strong></p>
<ul>
<li>暴力求解(Brute force)</li>
<li>分治法(Divide and conquer)</li>
<li>贪婪算法(Greedy approach)</li>
<li>动态规划(Backtracking)</li>
<li>回溯法(Branch and bound)</li>
<li>分支界限法(Randomized algorithm)等</li>
</ul>
<p><strong>算法</strong>：算法是借助计算机解决问题的方法，是有限条确定性指令的序列</p>
<p><strong>算法的性质</strong>：输入、输出、确定性、有限性</p>
<p><strong>算法的描述方式</strong>：自然语言、数学公式、流程图、伪代码、程序设计语言</p>
<p><strong>算法的评价方法：</strong>正确性、有效性、易理解、易实现、通用性</p>
<p><strong>例子：最大公约数</strong><br>暴力解法：取min(a,b)，从大到小尝试，直到两个数均可被整除。<br>欧几里得：<code>max%min==0？result=min : result=(max%min和min的最大公约数）</code></p>
<h3 id="1-2-算法复杂度"><a href="#1-2-算法复杂度" class="headerlink" title="1.2 算法复杂度"></a>1.2 算法复杂度</h3><p><strong>算法复杂度分析的三种情形</strong>：</p>
<ul>
<li>最好情形(Best case)</li>
<li>最差情形(Worst case)</li>
<li>平均情形(Average case)</li>
</ul>
<p>例如：二分查找(Binary search)的时间复杂度，在三种情况依次为Θ(1)、Θ(log<sub>2</sub>n)、Θ(log<sub>2</sub>n)</p>
<h4 id="1-2-1-时间复杂度"><a href="#1-2-1-时间复杂度" class="headerlink" title="1.2.1 时间复杂度"></a>1.2.1 时间复杂度</h4><p><strong>评价标准：</strong></p>
<ul>
<li>运行时间<ul>
<li>优点：最直接反映</li>
<li>缺点：机器依赖、缺乏解释</li>
</ul>
</li>
<li>运算次数<ul>
<li>优点：机器无关、具有解释力</li>
<li>缺点：统计繁琐、规模较大时关键在于增长量级</li>
</ul>
</li>
<li>增长量级</li>
</ul>
<p><strong>近似表示</strong><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.1.jpg?raw=true" alt="@图 1.1 上界|center|500x0"><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.2.jpg?raw=true" alt="@图 1.2 下界|center|500x0"><br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.3.jpg?raw=true" alt="@图 1.3 同阶|center|500x0"></p>
<p><strong>例子：Fibonacci</strong><br>递归算法：O(2<sup>n</sup>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">GetByRecursion</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> GetByRecursion(n-<span class="number">1</span>)+GetByRecursion(n-<span class="number">2</span>); <span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代算法：O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">GetByIteration</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">long</span> temp=a+b;</span><br><span class="line">		a=b;</span><br><span class="line">		b=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-算法思维"><a href="#1-3-算法思维" class="headerlink" title="1.3 算法思维"></a>1.3 算法思维</h3><p><strong>算法思维：</strong>现实问题——&gt;形式化描述——&gt;设计算法——&gt;方案实施——&gt;现实问题</p>
<h4 id="1-1-4-例：交通信号灯"><a href="#1-1-4-例：交通信号灯" class="headerlink" title="1.1.4 例：交通信号灯"></a>1.1.4 例：交通信号灯</h4>]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之8分治法解决赛程安排问题</title>
    <url>/2020/06/28/%E7%AE%97%E6%B3%95%E4%B9%8B8%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%A3%E5%86%B3%E8%B5%9B%E7%A8%8B%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="2-8-赛程安排"><a href="#2-8-赛程安排" class="headerlink" title="2.8 赛程安排"></a>2.8 赛程安排</h3><h4 id="2-8-1-问题描述"><a href="#2-8-1-问题描述" class="headerlink" title="2.8.1 问题描述"></a>2.8.1 问题描述</h4><p>n(n=2<sup>k</sup>)个选手参赛，设计一个满足以下要求的比赛日程表：</p>
<ul>
<li>每个选手必须与其他n-1个选手各比赛一次；</li>
<li>每个选手一天只能比赛一次；</li>
<li>循环赛一共进行n-1天。</li>
</ul>
<p>我们需要得出如下这样的的赛程表：<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.9.jpg?raw=true" alt="@图2.8 赛程表"></p>
<h4 id="2-8-2-算法思路"><a href="#2-8-2-算法思路" class="headerlink" title="2.8.2 算法思路"></a>2.8.2 算法思路</h4><p><strong>整体思路：</strong>由赛程表我们可以看出，赛程表分为四大区域，我们要做的是，</p>
<ul>
<li>将左上角的内容复制到右下角</li>
<li>左上角的内容加上n/2得到左下角</li>
<li>左下角复制到右上角</li>
</ul>
<p>区域不断以2指数倍增大，并不断重复上述步骤，最终填满整张表。</p>
<h4 id="2-8-3-代码实现"><a href="#2-8-3-代码实现" class="headerlink" title="2.8.3 代码实现"></a>2.8.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getSchedule(<span class="keyword">int</span> k) &#123;</span><br><span class="line">	<span class="keyword">int</span> n=(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,k);</span><br><span class="line">	<span class="keyword">int</span>[][] table=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];<span class="comment">//建表</span></span><br><span class="line">	table[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> newStartIndex=(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> newLength=newStartIndex*<span class="number">2</span>;</span><br><span class="line">		<span class="comment">/*核心代码*/</span></span><br><span class="line">		matrixCopy(table,<span class="number">0</span>,<span class="number">0</span>,newStartIndex,newStartIndex,newLength/<span class="number">2</span>);<span class="comment">//左上角复制到右下角</span></span><br><span class="line">		matrixCopyAdd(table,<span class="number">0</span>,<span class="number">0</span>,newStartIndex,<span class="number">0</span>,newLength/<span class="number">2</span>,newLength/<span class="number">2</span>);<span class="comment">//左上角复制并增加到左下角</span></span><br><span class="line">		matrixCopy(table,newStartIndex,<span class="number">0</span>,<span class="number">0</span>,newStartIndex,newLength/<span class="number">2</span>);<span class="comment">//左下角复制到右上角</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> table;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line"><span class="comment">//复制且增加</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrixCopyAdd</span><span class="params">(<span class="keyword">int</span>[][] table, <span class="keyword">int</span> i_s, <span class="keyword">int</span> j_s, <span class="keyword">int</span> i_d, <span class="keyword">int</span> j_d, <span class="keyword">int</span> length, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++) &#123;</span><br><span class="line">			table[i_d+i][j_d+j]=table[i_s+i][j_s+j]+add;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////</span></span><br><span class="line"><span class="comment">//复制</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrixCopy</span><span class="params">(<span class="keyword">int</span>[][] table, <span class="keyword">int</span> i_s, <span class="keyword">int</span> j_s, <span class="keyword">int</span> i_d, <span class="keyword">int</span> j_d,  <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++) &#123;</span><br><span class="line">			table[i_d+i][j_d+j]=table[i_s+i][j_s+j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Divide and conquer</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之12动态规划解决切木材问题</title>
    <url>/2020/06/30/%E7%AE%97%E6%B3%95%E4%B9%8B12%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E5%88%87%E6%9C%A8%E6%9D%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="3-4-切木材问题-Rod-cutting-problem"><a href="#3-4-切木材问题-Rod-cutting-problem" class="headerlink" title="3.4 切木材问题(Rod-cutting problem)"></a>3.4 切木材问题(Rod-cutting problem)</h3><h4 id="3-4-1-问题描述"><a href="#3-4-1-问题描述" class="headerlink" title="3.4.1 问题描述"></a>3.4.1 问题描述</h4><p>给一个长度为17的木材，可以切成小段卖出，价格根据小段的长度不同而不同。如何通过切成小段卖出尽可能高的总价钱？<br><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.16.jpg?raw=true" alt=""></p>
<h4 id="3-4-2-算法思路"><a href="#3-4-2-算法思路" class="headerlink" title="3.4.2 算法思路"></a>3.4.2 算法思路</h4><p><strong>总体思路：</strong><br>① 假如我们只有1米长的木材，那么就直接按1米的价格卖；<br>② 假如我们有2米长木材，那么可以切成两段卖(1+1=2元)或者直接按2米卖(4元)，所以两米时我们不切直接卖；<br>③ 假如我们有3米，那么我们可以直接按3米卖(5元)，或者切成一段1米和一段2米(1+4=5元)，此时，两种方案都行，都能取到最大收益5元。<em>注意：这里不能够切成三段1米卖，因为一旦有2米，我们就直接按2米卖获得的收益最高，所以不能把2米再切成两段1米。</em>这就是我们解法的关键点，我们后面一旦遇到2米，就直接看Length=2时的value，它代表着2米的最高利益。<br>依此类推….<br>④ 假如我们有10米，那么可以直接10米卖（30元）或者切成1米和9米（1+24=25元），或者切成2米和8米（4+20=24元），……，或者5米和5米（10+10=20元），把所有可能进行比较，最终选择其中价值最高的直接10米卖也就是，30元。<br>一旦超过10米之后，就没有直接卖的价格了，此时就只需要比较切开卖法的价格。</p>
<p><img src="https://github.com/boomboomchen/markdownImages/blob/master/1.17.jpg?raw=true" alt=""></p>
<p><strong>动态规划思想：</strong></p>
<ul>
<li>问题分阶段：把length=n的大问题，分为了一个个小问题</li>
<li>阶段有依赖：当我们算到后面大长度的时候，一旦出现某个小长度，我们就可以直接去看对应长度的value值，它代表着这个长度的最大收益，当我们在处理大问题时，都依赖于之前小问题的解。</li>
<li>依赖有重合：当我们在处理大长度的时候，就不用重复计算小长度的买法，避免了重复计算。</li>
</ul>
<h4 id="3-4-3-表格法代码实现"><a href="#3-4-3-表格法代码实现" class="headerlink" title="3.4.3 表格法代码实现"></a>3.4.3 表格法代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表格法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span>[] cut_value,<span class="keyword">int</span> rod_length)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] rod_value=<span class="keyword">new</span> <span class="keyword">int</span>[rod_length];</span><br><span class="line">	rod_value[<span class="number">0</span>]=cut_value[<span class="number">0</span>];<span class="comment">//长度为1时，木材价值直接等于对应价格</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rod_length;i++)&#123;</span><br><span class="line">		<span class="comment">/*核心代码*/</span></span><br><span class="line">		rod_value[i]=cut_value[Math.min(i,cut_value.length-<span class="number">1</span>)];<span class="comment">//木材价值value先初始化为对应长度的价格price，如果木材长度超过提供价格的木材长度，就直接使用最长长度的价格。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">			rod_value[i]=Math.max(rod_value[i],rod_value[j]+rod_value[i-j-<span class="number">1</span>]);<span class="comment">//对应长度木材的价格，依次首尾相加的价格里面取其大者</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rod_value[rod_length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-4-备忘录法代码实现"><a href="#3-4-4-备忘录法代码实现" class="headerlink" title="3.4.4 备忘录法代码实现"></a>3.4.4 备忘录法代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//备忘录法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValueByMemoization</span><span class="params">(<span class="keyword">int</span>[] cut_values, <span class="keyword">int</span> rod_length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] rod_values = <span class="keyword">new</span> <span class="keyword">int</span>[rod_length];</span><br><span class="line">	rod_values[<span class="number">0</span>] = cut_values[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> getValueByMemoization(cut_values, rod_length, rod_values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValueByMemoization</span><span class="params">(<span class="keyword">int</span>[] cut_values, <span class="keyword">int</span> rod_length, <span class="keyword">int</span>[] rod_values)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( rod_values[rod_length-<span class="number">1</span>]&gt;<span class="number">0</span>)<span class="comment">//数值已经存在则无需求解</span></span><br><span class="line">		<span class="keyword">return</span> rod_values[rod_length-<span class="number">1</span>];</span><br><span class="line">	rod_values[rod_length-<span class="number">1</span>] = cut_values [Math.min(rod_length-<span class="number">1</span>,cut_values.length-<span class="number">1</span>)];<span class="comment">//木材价值value先初始化为对应长度的价格price，如果木材长度超过提供价格的木材长度，就直接使用最长长度的价格。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=(rod_length-<span class="number">1</span>)/<span class="number">2</span>;j++) &#123;</span><br><span class="line">		rod_values[rod_length-<span class="number">1</span>] = Math. max( rod_values[rod_length-<span class="number">1</span>],</span><br><span class="line">		getValueByMemoization(cut_values, j+<span class="number">1</span>, rod_values) +getValueByMemoization(cut_values, rod_length-j-<span class="number">1</span>,  rod_values));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  rod_values[rod_length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-5-算法复杂度"><a href="#3-4-5-算法复杂度" class="headerlink" title="3.4.5 算法复杂度"></a>3.4.5 算法复杂度</h4><p>算法复杂度：Θ(n<sup>2</sup>)<br>分析：每算出一个子长度i对应的值，都要经过i/2次比较，若木材总长度为n，则需要求出n个子长度，所以Θ(n<sup>2</sup>)</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>Dynamic Programming</tag>
        <tag>Rod-cutting problem</tag>
      </tags>
  </entry>
</search>
